

  C# 2008: ускоренный курс для профессионалов


          Автор: Трей Нэш
          Издательство: Вильямс, 2008
          <http://www.williamspublishing.com/Books/978-5-8459-1377-7.html>
          576 страниц
          ISBN: 978-5-8459-1377-7
          <http://www.findbook.ru/search?isbn=978-5-8459-1377-7&ozon=rsdn&biblion=791&booksru=rsdn&zonex=248&piter=3600&myshop=00776&s36=rsdn>
          ISBN: 978-1-59059-873-3
          <http://www.findbook.ru/search?isbn=978-1-59059-873-3&ozon=rsdn&biblion=791&booksru=rsdn&zonex=248&piter=3600&myshop=00776&s36=rsdn>



    Аннотация

Книга ведущего специалиста в области технологий .NET представляет собой
интенсивный курс по новейшей версии языка C#, воплотившей в себе важные
дополнения и предлагающей среду, в которой функциональное
программирование может органично переплетаться с обычным стилем
императивного программирования на C#. Подробно рассматриваются такие
темы, как фундаментальные принципы объектно-ориентированного
проектирования, основные структуры данных, обработка исключений,
делегаты, анонимные функции, контракты и интерфейсы, события, обобщения
и многопоточность, а также нововведения наподобие лямбда-выражений,
расширяющих методов и языка LINQ. Книга изобилует множеством примеров,
которые не только иллюстрируют концепции, но также демонстрируют способы
правильной разработки и умеренного их применения в реальных условиях.
Книга рассчитана на программистов разной квалификации, а также будет
полезна студентам и преподавателям дисциплин, связанных с
программированием и разработкой для.NET.


    Оглавление

Предисловие
Предисловие
Об авторе
О техническом редакторе
Благодарности
*Введение *
Как организована эта книга
От издательства

*Глава 1. Обзор C# *

*Отличия между C# и C++ *
Язык C#
Язык C++
Сборка мусора CLR
Пример программы на C#
Обзор средств, добавленных в C# 2.0
Обзор новшеств C# 3.0
Резюме

*Глава 2. C# и CLR *

*JIT-компилятор и CLR *
Сборки и загрузчик сборок
Минимизация рабочего набора приложения
Присвоение имен сборкам
Загрузка сборок
Метаданные
Межязыковые возможности
Резюме

*Глава 3. Обзор синтаксиса C# *

C# - строго типизированный язык
Выражения
Операторы и выражения
*Типы и переменные *
Типы значений
Ссылочные типы
Инициализация переменных по умолчанию
Неявно типизированные локальные переменные
Преобразования типов
Операции as и is
Обобщения
*Пространства имен *
Определение пространств имен
Использование пространств имен
*Поток управления *
if-else, while, do-while и for
switch
foreach
break, continue, goto, return и throw
Резюме

*Глава 4. Классы, структуры и объекты *

*Определения классов *
Поля
Конструкторы
Методы
Свойства
Инкапсуляция
Доступность
Интерфейсы
Наследование
Герметизированные классы
Абстрактные классы
Вложенные классы
Индексаторы
Частичные классы
Частичные методы
Статические классы
Зарезервированные имена членов
*Определения типов значений*
Смысл this
Финализаторы
Интерфейсы
Анонимные типы
Инициализаторы объектов
*Упаковка и распаковка*
Когда происходит упаковка
Эффективность и путаница
*System.Object*
Эквивалентность и ее смысл
Интерфейс IComparable
*Создание объектов*
Ключевое слово new
Инициализация полей
Статические конструкторы (класса)
Конструктор экземпляра и порядок создания
*Уничтожение объектов*
Финализаторы
Детерминированное уничтожение
Обработка исключений
*Одноразовые (disposable) объекты*
Интерфейс IDisposable
Ключевое слово using
*Типы параметров методов*
Аргументы-значения
Аргументы ref
Параметры out
Массивы params
Перегрузка методов
*Наследование и виртуальные методы*
Виртуальные и абстрактные методы
Методы new и override
Методы sealed
Завершающие несколько слов о виртуальных методах C#
*Наследование, включение и делегирование*
Выбор между интерфейсом и наследованием класса
Сравнение делегирования и композиции и наследования
Резюме

*Глава 5. Интерфейсы и контракты*

Интерфейсы определяют типы
*Определение интерфейсов*
Что может быть интерфейсом?
Наследование интерфейсов и сокрытие членов
*Реализация интерфейсов*
Неявная реализация интерфейса
Явная реализация интерфейса
Переопределение реализаций интерфейсов в производных классах
Берегитесь побочных эффектов от реализации интерфейсов типами значений
Правила сопоставления членов интерфейсов
Явная реализация интерфейса с типами значений
Соображения, касающиеся версий
*Контракты*
Контракты, реализованные классами
Интерфейсные контракты
Выбор между интерфейсами и классами
Резюме

*Глава 6. Перегрузка операций*

Можете - не значит должны
Типы и форматы перегруженных операций
Операции не должны изменять свои операнды
Имеет ли значение порядок параметров?
Перегрузка операции сложения
*Операции, допускающие перегрузку*
Операции сравнения
Операции преобразования
Булевские операции
Резюме

*Глава 7. Исключения: безопасность и обработка*

Как CLR трактует исключения
*Механика обработки исключений в C#*
Генерация исключений
Изменения, касающиеся необработанных исключений, которые появились в
.NET 2.0
Обзор синтаксиса оператора try
Повторная генерация и трансляция исключений
Исключения, сгенерированные в блоке finally
Исключения, сгенерированные в финализаторах
Исключения, сгенерированные в статических конструкторах
Кто должен обрабатывать исключения?
Избегайте применения исключений для управления потоком выполнения
*Обеспечение нейтральности к исключениям*
Базовая структура нейтрального к исключениям кода
Ограниченные области выполнения
Критичные финализаторы и SafeHandle
Создание пользовательских классов исключений
Работа с выделенными ресурсами и исключениями
Обеспечение поведения отката
Резюме

*Глава 8. Работа со строками*

Обзор String
Строковые литералы
*Спецификаторы формата и глобализация*
Object.ToString, IFormattable и CultureInfo
Создание и регистрация пользовательских типов CultureInfo
Форматные строки
Console.WriteLine и String.Format
Примеры строкового форматирования в пользовательских типах
ICustomFormatter
Сравнение строк
Работа со строками из внешних источников
StringBuilder
*Поиск строк с помощью регулярных выражений*
Поиск с помощью регулярных выражений
Поиск и группирование
Замена текста с помощью Regex
Варианты создания Regex
Резюме

*Глава 9. Массивы, типы коллекций и итераторы*

*Представление массивов*
Неявно типизированные массивы
Конвертируемость и ковариантность
Возможности сортировки и поиска
Синхронизация
Векторы против массивов
Многомерные прямоугольные массивы
Многомерные зубчатые массивы
*Типы коллекций*
Сравнение ICollection<T> с ICollection
Синхронизация коллекций
Списки
Словари
Наборы
System.Collections.ObjectModel
Эффективность
*IEnumerable<T>, IEnumerator<T>, IEnumerable и IEnumerator*
Типы, производящие коллекции
*Итераторы*
Прямые, обратные и двунаправленные итераторы
Инициализаторы коллекций
Резюме

*Глава 10. Делегаты, анонимные функции и события*

Обзор делегатов
*Создание и использование делегатов*
Одиночный делегат
Цепочки делегатов
Итерация по цепочкам делегатов
Несвязанные делегаты (открытые экземпляры)
События
*Анонимные методы*
Остерегайтесь сюрпризов захваченных переменных
Анонимные методы как привязки параметров делегатов
Шаблон Strategy
Резюме

*Глава 11. Обобщения*

Разница между обобщениями и шаблонами C++
Эффективность и безопасность типов обобщений
*Определения обобщенных конструируемых типов*
Обобщенные классы и структуры
Обобщенные интерфейсы
Обобщенные методы
Обобщенные делегаты
Преобразование обобщенного типа
Выражение значения по умолчанию
Типы, допускающие значения null
Контроль доступа к конструируемым типам
Обобщения и наследование
*Ограничения*
Ограничения на неклассовых типах
Обобщенные системные коллекции
Обобщенные системные интерфейсы
*Проблемы выбора и их решение*
Преобразования и операции внутри обобщенных типов
Динамическое создание конструируемых типов
Резюме

*Глава 12. Многопоточность в C#*

*Многопоточность в C# и .NET*
Запуск потоков
Шаблон IOU и асинхронные вызовы методов
Состояния потока
Завершение потоков
Останавливающиеся и пробуждающиеся потоки
Ожидание завершения потока
Потоки переднего плана и фоновые потоки
Локальное хранилище потока
Как неуправляемые потоки и апартаменты COM приспособлены друг к другу
*Синхронизация между потоками*
Легковесная синхронизация с помощью класса Interlocked
Класс Monitor
Блокирующие объекты
Семафоры
События
Объекты синхронизации Win32 и WaitHandle
*Использование ThreadPool*
Асинхронные вызовы методов
Таймеры
Резюме

*Глава 13. В поисках канонических форм C#*

*Канонические формы ссылочных типов*
Классы должны помечаться как sealed по умолчанию
Использование шаблона NVI
Является ли Object клонируемым?
Является ли Object одноразовым?
Нужен ли финализатор Object?
Если переопределили Equals, переопределите и GetHashCode
Поддерживает ли объект упорядочивание?
Является ли Object форматируемым?
Является ли Object преобразуемым?
Всегда отдавайте предпочтение безопасности типов
Использование неизменных ссылочных типов
*Канонические формы типов значений*
Переопределение Equals для повышения производительности
Поддерживают ли значения этого типа какие-либо интерфейсы?
Реализация безопасных к типам форм членов интерфейса и унаследованных
методов
*Резюме*
Список вопросов для ссылочных типов
Список вопросов для типов значений

*Глава 14. Расширяющие методы*

*Введение в расширяющие методы*
Как компилятор находит расширяющие методы?
За кулисами
Читабельность или понятность
*Рекомендации по использованию*
Использование расширяющих методов вместо наследования
Изоляция расширяющих методов в отдельном пространстве имен
Изменение контракта типа может разрушить расширяющие методы
Трансформации
Цепочки операций
*Пользовательские итераторы*
Заимствование из функционального программирования
Шаблон Visitor
Резюме

*Глава 15. Лямбда-выражения <http://rsdn.ru/article/dotnet/cslambda.xml>*

*Введение в лямбда-выражения*
Лямбда-выражения
Лямбда-операторы
*Деревья выражений*
Операции над выражениями
Функции как данные
*Полезные применения лямбда-выражений*
Вернемся к итераторам и генераторам
Замыкания (захват переменной) и мемоизация
Приправа
Анонимная рекурсия
Резюме

*Глава 16. LINQ: язык интегрированных запросов*

*Мост к данным*
Выражения запросов
Вернемся к расширяющим методам и лямбда-выражениям
Стандартные операции запросов
*Ключевые слова запросов C#*
Конструкция from и переменные диапазона
Конструкция join
Конструкция where и фильтры
Конструкция orderby
Конструкция select и проекция
Конструкция let
Конструкция group
Конструкция into и продолжение
*Добродетель лени*
Поощрение лени итераторами C#
Ниспровержение лени
Немедленное выполнение запросов
Еще раз о деревьях выражений
*Приемы функционального программирования*
Пользовательские стандартные операции запросов и ''ленивое вычисление''
Замена операторов foreach
Резюме

Приложение. Справочная информация

Предметный указатель


    Предисловие

Программирование доставляет удовольствие. Это - захватывающее
путешествие сквозь проблемы сознания, украшенное чудесными пейзажами
открытий. На протяжении всего процесса программистское видение проблем и
их решений формируется сквозь призму используемого языка и
продиктованного им образа мышления. Поэтому для программиста чрезвычайно
важно хорошее знание этого языка.

Проблемы, над которыми трудятся разработчики настолько разнообразны,
насколько разнообразны и сами разработчики. Они простираются от
медицинских приложений до программного обеспечения страхового дела, от
мультимедийных приложений до инструментов добычи данных. Эволюция C#
практически повторяет эволюцию проблем, с которыми сталкиваются
разработчики. По мере усложнения проблем происходило упрощение языка и
повышение его мощности, позволяющее справиться с возрастающей сложностью.

C# начинался, как способ описания многократно используемых компонентов,
которые работают в широком разнообразии исполняющих сред. На этой фазе
он зарекомендовал себя в роли великолепного языка для описания
архитектуры компонентов и систем, при этом сохраняя в себе и расширяя
свои корни C-подобного языка. Одним из главных приобретений C# стала
полностью объектно-ориентированная система типов, унифицирующая
концепции примитивных и сложных типов, а также сборщик мусора.

В то время, как первая версия C# была главным достижением, второй релиз
стал определяющим моментом в формировании языка. Система типов стала
намного богаче с появлением обобщений (generics). Язык также начал
поддерживать такие средства, как итераторы и анонимные методы, открывшие
возможность более простого и элегантного дизайна. Эти средства позволили
разрабатывать более гибкие и мощные каркасы.

Третья версия C# действительно открыла новую страницу в развитии языка.
Она размыла линию между кодом и данными. Она представила декларативный
синтаксис запросов. Она снабдила программистов новыми функциональными
средствами. Все эти новшества позволили программистам легче справляться
с данными, находящимися в памяти, в базе данных или поступающими от
web-сервера. Программисты убедятся, что все эти средства вернули им
радость от программирования.

В настоящей книге Нэш представил свежее, ясное толкование языка C#. Он
не только глубоко понимает C#, но также умеет провести читателя сквозь
весь процесс изучения для совершенствования знаний языка. Он умеет
сделать путь познания увлекательным, приводя стимулирующие мышление
примеры, находя время убедительно мотивировать полезность каждого
средства, демонстрирует распространенные приемы и передовой опыт. Я
уверен, что, изучив эту книгу, читатель станет писать лучший код.

Вес Дийер (Wes Dyer)

Команда проектировщиков языка и компилятора C#, Microsoft Corporation.


    Введение

Visual C# .NET (C#) изучить относительно легко любому, кто знаком с
другим объектно-ориентированным языком. Даже человек, знакомый с Visual
Basic 6.0, которому нужен объектно-ориентированный язык, обнаружит, что
понять C# нетрудно. Однако, несмотря на то, что C# вместе с .NET
Framework предоставляют легкий путь создания простых приложений, все же
вам понадобится немало знаний и понимания того, как их правильно
применять для создания сложных, надежных и устойчивых к сбоям приложений
C#. В этой книге я научу вас всему, что необходимо знать, и расскажу,
как наилучшим образом применять знания для того, чтобы быстро достичь
уровня настоящего специалиста в C#.

Идиомы и шаблоны проектирования незаменимы для повышения уровня
мастерства разработчика и применения его на практике, так что я покажу
вам, как использовать многие из них для создания приложений -
эффективных, надежных, устойчивых к сбоям и безопасных в отношении
исключений. Хотя многие из этих шаблонов знакомы программистам на C++ и
Java, все же некоторые уникальны для .NET и его общеязыковой исполняющей
среды (Common Language Runtime - CLR). В последующих главах будет
показано, как применять эти обязательные идиомы и приемы проектирования
для гладкой интеграции ваших приложений C# с исполняющей системой .NET,
причем основное внимание сосредоточивается на новых средствах C# 3.0.

Шаблоны проектирования документируют передовой опыт в проектировании
приложений, который накоплен множеством программистов в течение
длительного времени. Фактически .NET Framework сам по себе реализует
многие хорошо известные шаблоны проектирования. К тому же последние три
версии .NET Framework и две версии C# высветили многие новые идиомы и
передовые приемы. Вы будете знакомиться с ними на протяжении всей книги.
К тому же важно отметить, что этот бесценный набор технологий постоянно
эволюционирует.

С появлением C# 3.0 вы получили возможность легко включать приемы
функционального программирования, используя лямбда-выражения,
расширяющие методы и язык интегрированных запросов (Language Integrated
Query - LINQ). Лямбда-выражения облегчают объявление и создание
экземпляров делегатов функций в одном месте. Вдобавок к
лямбда-выражениям появилась возможность создавать функционалы - функции,
принимающие в качестве аргументов функции и обычно возвращающие другие
функции. Несмотря на то что вы могли реализовать технику
программирования функционалов на C# (хотя и с некоторыми трудностями),
новые средства языка C# 3.0 обеспечили среду, в которой программирование
функционалов может органично переплетаться с обычным стилем
императивного программирования C#. LINQ позволяет выразить операции
запроса данных (которые обычно по природе своей являются функционалами),
используя естественный для языка синтаксис. Однажды увидев, как работает
LINQ, вы поймете, что можете сделать много больше, чем простой запрос
данных; вы можете использовать его для реализации сложных функциональным
программ.

.NET и CLR предоставляют уникальную и стабильную межплатформенную
исполняющую среду. C# - только один из языков, ориентированных на эту
мощную исполняющую систему. Вы обнаружите, что многие из приемов,
описанных в этой книге, также применимы к любому языку, ориентированному
на исполняющую систему .NET. Тем из вас, у кого есть серьезный опыт
работы на C++, и кто знаком с такими концепциями, как канонические формы
C++, безопасность исключений, RAII (Resource Acquisition Is
Initialization - захват ресурсов является инициализацией), а также
корректность констант, книга объяснит, как применить все эти концепции в
C#. Если вы - программист на Java или Visual Basic, который потратил
годы на разработку собственного набора приемов, и хотите знать, как
эффективно применить их в C#, вы найдете здесь ответ и на этот вопрос.

Как вы вскоре убедитесь, для того, чтобы стать экспертом в C#, не нужно
тратить годы на приобретение опыта методом проб и ошибок. Вам просто
нужно изучить правильные вещи и правильные способы того, как их следует
делать. Именно потому я написал эту книгу для вас.


    Как организована эта книга

Я предполагаю, что вы уже имеете практический опыт работы с некоторым
объектно-ориентированным языком, таким как C++, Java или Visual Basic
.NET. Поскольку C# унаследовал свой синтаксис от C++ и Java, я не стану
тратить много времени на описание синтаксиса C#, за исключением тех
моментов, в которых он отличается от C++ или Java. Если вы уже немного
знаете C#, то можете лишь пролистать или вообще пропустить главы с 1 по 3.

*Глава 1, "Обзор C#"*, даст вам первоначальное представление о том, как
выглядит простое приложение C#, и предложит описание некоторых базовых
отличий среды программирования C# от среды "родного" C++.

*Глава 2, "C# и CLR"*, разовьет тему главы 1 и кратко ознакомит с
управляемой средой, внутри которой выполняется приложение C#. Я расскажу
о сборках - базовых строительных блоках приложений, в которые
компилируются файлы кода C#. Вдобавок вы увидите, как метаданные делают
сборки самодостаточными.

*Глава 3, "Обзор синтаксиса C#"*, предоставит описание синтаксиса языка
C#. Я продемонстрирую две фундаментальных группы типов CLR: типы
значений и ссылочные типы. Также я опишу пространства имен и то, как вы
можете использовать их для логического разбиения типов и
функциональности внутри ваших приложений.

*Главы с 4 по 13* содержат углубленные описания применения полезных
идиом, шаблонов проектирования и передовых приемов в ваших программах и
проектах C#. Я попытался выстроить эти главы в логическом порядке, но
неизбежно одни главы могут ссылаться на приемы или темы, описанные в
других (последующих) главах.

*Глава 4, "Классы, структуры и объекты"*, содержит подробности
определения типов в C#. Вы узнаете больше о типах значений и ссылочных
типах в CLR. Я также коснусь "родной" поддержки интерфейсов внутри CLR и
C#. Вы увидите, как работает наследование в C#, а также каким образом
каждый объект наследуется от типа System.Object. Эта глава также
содержит богатую информацию об управляемой среде и о том, что вам нужно
знать, чтобы определять типы, удобные для нее. Я представлю многие из
таких тем в этой главе и продолжу дискуссию более подробно в последующих
главах.

*Глава 5, "Интерфейсы и контракты"*, посвящена интерфейсам и роли,
которую они играют в языке C#. Интерфейсы представляют собой контракт
функциональности, которую могут реализовывать типы. Вы узнаете о многих
способах реализации интерфейсов типами, а также о том, как исполняющая
система выбирает, какие методы нужно вызывать при вызове методов интерфейса.

*Глава 6, "Перегрузка операций"*, детализирует способы создания
специальной функциональности встроенных операций языка C#, когда они
применяются к вашим собственным типам. Вы увидите, как перегрузить
действие операций, хотя не все управляемые языки, которые компилируются
в код для CLR, способны использовать перегруженные операции.

*Глава 7, "Исключения: безопасность и обработка"*, посвящена средствам
обработки исключений языка C# и CLR. Хотя синтаксис подобен C++,
создание безопасного и нейтрального в отношении исключений кода не так
просто - даже сложнее создания безопасного к исключениям кода на
"родном" C++. Вы увидите, что написание устойчивого к сбоям, безопасного
к исключениям кода вообще не требует применения конструкций try, catch
или finally. Я также опишу некоторые новые возможности, добавленные в
исполняющую систему .NET 2.0, которые позволят вам создавать более
устойчивый к сбоям код, чем это было возможно в .NET 1.1.

*Глава 8, "Работа со строками"*, описывает строки - первоклассный тип
CLR - и методы их эффективного применения в C#. Значительная часть этой
главы посвящена средствам строкового форматирования различных типов в
.NET Framework и тому, как заставить определенные вами типы вести себя
подобным образом - посредством реализации Iformattable. Дополнительно я
представлю средства глобализации каркаса и расскажу, как создавать
собственные CultureInfo для культур и регионов, о которых .NET Framework
не имеет понятия.

*Глава 9, "Массивы, типы коллекций и итераторы"*, расскажет о
разнообразных массивах и типах коллекций, доступных в C#. Вы можете
создавать два типа многомерных массивов наряду с собственными типами
коллекций, используя служебные классы коллекций. Вы увидите, как
определять прямые, обратные и двунаправленные итераторы, применяя новый
синтаксис итераторов, представленный в C# 2.0, так что ваши типы
коллекций смогут хорошо работать с операторами foreach.

*Глава 10, "Делегаты, анонимные функции и события"*, продемонстрирует
механизмы, используемые внутри C# для обеспечения обратных вызовов. C#
пошел на один шаг дальше, и инкапсулирует обратные вызовы в вызываемые
объекты, называемые /делегатами/. Вдобавок C# 2.0 позволяет создавать
делегаты с сокращенным синтаксисом, называемые /анонимными функциями/.
Анонимные функции подобны лямбда-функциям в функциональном
программировании. К тому же вы увидите, как на основе делегатов каркас
реализует механизм уведомления публикации/подписки на события, позволяя
отделять источник события от его потребителя.

*Глава 11, "Обобщения"*, представит, пожалуй, наиболее впечатляющее
средство, появившееся в C# 2.0 и CLR. Тем, кто знаком с шаблонами C++,
обобщения покажутся знакомыми, хотя между ними есть многие
фундаментальные отличия. Используя обобщения, вы можете создавать
оболочку функциональности, внутри которой во время выполнения
определяются более специфичные типы. Обобщения наиболее полезны для
типов коллекций и обеспечивают значительную эффективность по сравнению с
коллекциями из предыдущих версий .NET.

*Глава 12, "Многопоточность в C#"*, описывает то, что необходимо сделать
при создании многопоточных приложений в управляемой виртуальной
исполняющей системе C#. Если вы знакомы с потоками в родной среде Win32,
вы отметите существенные отличия. Более того, управляемая среда
предоставляет более развитую инфраструктуру для облегчения работы. Вы
увидите, как делегаты с использованием шаблона IOU ("I Owe You")
предоставляют отличные ворота в пул потоков обработки. Вероятно,
синхронизация - наиболее важная концепция, когда нужно заставить
несколько потоков работать параллельно. В этой главе описаны различные
средства синхронизации, доступные вашим приложениям.

*Глава 13, "В поисках канонических форм C#"*, - это своего рода
диссертация о передовых приемах проектирования при определении новых
типов, и о том, как сделать их такими, чтобы их применение было
естественным, и чтобы их потребители не могли использовать их
неправильно. Я буду касаться этой темы и в других главах, но здесь она
обсуждается в деталях. Эта глава снабжена подробным перечнем того, что
следует принимать во внимание при определении новых типов на C#.

*Глава 14, "Расширяющие методы"*, раскрывает средство, новое для C# 3.0.
Поскольку вы можете вызывать расширяющие методы как обычные методы
экземпляра с типом, который они расширяют, их можно воспринимать как
развитие контракта типов. Но на самом деле они представляют собой нечто
большее. В этой главе я покажу, как расширяющие методы могут открыть мир
функционального программирования на C#.

*Глава 15, "Лямбда-выражения"
<http://rsdn.ru/article/dotnet/cslambda.xml>*, посвящена еще одному
новому средству C# 3.0. Вы можете объявлять и создавать экземпляры
делегатов, используя лямбда-выражения с применением краткого и визуально
выразительного синтаксиса. Хотя той же цели могут служить и анонимные
функции, они намного более многословны и менее синтаксически элегантны.
Однако в C# 3.0 вы можете конвертировать лямбда-выражения в деревья
выражений. То есть язык имеет встроенную способность преобразовывать код
в структуры данных. Само по себе это средство полезно, но не настолько,
как в сочетании в языком интегрированных запросов (Language Integrated
Query - LINQ). В сочетании с расширяющими методами лямбда-выражения
действительно завершают полный цикл функционального программирования на C#.

*Глава 16, "LINQ: язык интегрированных запросов"*, - это кульминация
всех новых средств C# 3.0. Используя выражения LINQ через новые
LINQ-ориентированные ключевые слова C# 3.0, вы можете плавно
интегрировать запросы к данным в код. LINQ формирует мост между обычным
миром императивного программирования C# и миром функционального
программирования запросов к данным. Выражения LINQ могут быть
использованы для манипуляций нормальными объектами, равно как и данными,
полученными из баз данных SQL, наборов данных и XML - и это далеко не
полный перечень.


